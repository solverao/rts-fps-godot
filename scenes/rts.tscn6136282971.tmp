[gd_scene load_steps=13 format=3 uid="uid://bo4alqq10e4wb"]

[ext_resource type="PackedScene" uid="uid://cf7brgwaxlmud" path="res://addons/3d_rts_camera/rtscam.tscn" id="1_coxth"]
[ext_resource type="PackedScene" uid="uid://c3e4jgwt67ysd" path="res://scenes/plane.tscn" id="2_7jm3t"]
[ext_resource type="Script" uid="uid://06ac57g80glq" path="res://scripts/flow_field_3d.gd" id="3_7jm3t"]
[ext_resource type="Script" uid="uid://dmmcwcoij4mw6" path="res://scripts/selection_box_ui.gd" id="4_dsjwe"]

[sub_resource type="GDScript" id="GDScript_coxth"]
script/source = "extends Node3D

@onready var flow_field: FlowField3D = $FlowField3D
@onready var camera: Camera3D = $Camera3D
@export var unit_scene: PackedScene
@export var ground_layer: int = 1
@export var unit_layer: int = 2

var selected_units: Array = []
var all_units: Array = []

# Para box selection
var is_selecting: bool = false
var selection_start: Vector2 = Vector2.ZERO
var selection_end: Vector2 = Vector2.ZERO

func _ready():
	setup_obstacles()
	spawn_test_units()

func setup_obstacles():
	\"\"\"Configura obstáculos iniciales\"\"\"
	# Ejemplos de obstáculos
	flow_field.set_obstacle_area(Vector3(20, 0, 15), 3, true)
	flow_field.set_obstacle_area(Vector3(40, 0, 25), 4, true)
	flow_field.set_obstacle_area(Vector3(15, 0, 35), 2, true)
	
	# Áreas con costo elevado (terreno difícil)
	flow_field.set_cost_area(Vector3(30, 0, 30), 5, 3)  # Lodo/arena

func spawn_test_units():
	\"\"\"Crea unidades de prueba\"\"\"
	if not unit_scene:
		push_warning(\"No unit scene assigned\")
		return
	
	for i in range(12):
		var unit = unit_scene.instantiate()
		add_child(unit)
		
		var x = 5 + (i % 4) * 3
		var z = 5 + int(i / 4) * 3
		unit.global_position = Vector3(x, 0, z)
		
		all_units.append(unit)

func _input(event):
	if event is InputEventMouseButton:
		handle_mouse_click(event)
	
	elif event is InputEventMouseMotion and is_selecting:
		selection_end = event.position

func handle_mouse_click(event: InputEventMouseButton):
	\"\"\"Maneja clicks del mouse\"\"\"
	if event.button_index == MOUSE_BUTTON_RIGHT and event.pressed:
		# Click derecho: mover unidades
		var world_pos = get_world_position_from_mouse(event.position)
		if world_pos != Vector3.ZERO:
			move_selected_units(world_pos)
	
	elif event.button_index == MOUSE_BUTTON_LEFT:
		if event.pressed:
			# Iniciar selección
			selection_start = event.position
			is_selecting = true
			
			# Verificar si se clickeó una unidad
			if not Input.is_key_pressed(KEY_SHIFT):
				var unit = get_unit_at_mouse(event.position)
				if unit:
					clear_selection()
					select_unit(unit)
					is_selecting = false
		else:
			# Finalizar selección
			if is_selecting:
				selection_end = event.position
				perform_box_selection()
				is_selecting = false

func get_world_position_from_mouse(mouse_pos: Vector2) -> Vector3:
	\"\"\"Convierte posición del mouse a coordenadas 3D del mundo\"\"\"
	var from = camera.project_ray_origin(mouse_pos)
	var to = from + camera.project_ray_normal(mouse_pos) * 1000
	
	var space_state = get_world_3d().direct_space_state
	var query = PhysicsRayQueryParameters3D.create(from, to)
	query.collision_mask = ground_layer
	
	var result = space_state.intersect_ray(query)
	
	if result:
		return result.position
	
	return Vector3.ZERO

func get_unit_at_mouse(mouse_pos: Vector2) -> RTSUnit3D:
	\"\"\"Obtiene la unidad bajo el cursor del mouse\"\"\"
	var from = camera.project_ray_origin(mouse_pos)
	var to = from + camera.project_ray_normal(mouse_pos) * 1000
	
	var space_state = get_world_3d().direct_space_state
	var query = PhysicsRayQueryParameters3D.create(from, to)
	query.collision_mask = unit_layer
	
	var result = space_state.intersect_ray(query)
	
	if result and result.collider is RTSUnit3D:
		return result.collider
	
	return null

func perform_box_selection():
	\"\"\"Selecciona unidades dentro del área de selección\"\"\"
	var rect = get_selection_rect()
	
	if not Input.is_key_pressed(KEY_SHIFT):
		clear_selection()
	
	for unit in all_units:
		var screen_pos = camera.unproject_position(unit.global_position)
		if rect.has_point(screen_pos):
			select_unit(unit)

func get_selection_rect() -> Rect2:
	\"\"\"Crea un rectángulo desde el inicio hasta el final de la selección\"\"\"
	var start = selection_start
	var end = selection_end
	
	var min_x = min(start.x, end.x)
	var min_y = min(start.y, end.y)
	var width = abs(end.x - start.x)
	var height = abs(end.y - start.y)
	
	return Rect2(min_x, min_y, width, height)

func select_unit(unit: RTSUnit3D):
	\"\"\"Selecciona una unidad\"\"\"
	if unit not in selected_units:
		selected_units.append(unit)
		unit.set_selected(true)

func clear_selection():
	\"\"\"Limpia la selección actual\"\"\"
	for unit in selected_units:
		unit.set_selected(false)
	selected_units.clear()

func move_selected_units(target_pos: Vector3):
	\"\"\"Mueve las unidades seleccionadas al objetivo\"\"\"
	if selected_units.size() == 0:
		return
	
	# Generar flow field
	flow_field.generate_flow_field(target_pos)
	
	# Aplicar formación (spread circular)
	var spread_radius = 2.0
	var angle_step = TAU / selected_units.size() if selected_units.size() > 1 else 0
	
	for i in range(selected_units.size()):
		var unit = selected_units[i]
		var offset = Vector3.ZERO
		
		if selected_units.size() > 1:
			var angle = i * angle_step
			offset = Vector3(cos(angle), 0, sin(angle)) * spread_radius
		
		unit.set_target(target_pos + offset)

func add_obstacle_at_position(world_pos: Vector3, radius: int = 2):
	\"\"\"Añade un obstáculo en tiempo real\"\"\"
	flow_field.set_obstacle_area(world_pos, radius, true)
	
	# Regenerar flow field si hay unidades en movimiento
	for unit in selected_units:
		if unit.is_moving:
			flow_field.generate_flow_field(unit.target_position)
			break

func _process(_delta):
	# Debug: Toggle visualización
	if Input.is_action_just_pressed(\"ui_accept\"):
		flow_field.debug_draw = !flow_field.debug_draw
		if flow_field.debug_draw:
			flow_field.update_debug_visualization()
		else:
			flow_field.clear_debug()
	
	# Debug: Añadir obstáculo con tecla O
	if Input.is_action_just_pressed(\"ui_cancel\"):
		var mouse_pos = get_viewport().get_mouse_position()
		var world_pos = get_world_position_from_mouse(mouse_pos)
		if world_pos != Vector3.ZERO:
			add_obstacle_at_position(world_pos, 2)
"

[sub_resource type="ProceduralSkyMaterial" id="ProceduralSkyMaterial_coxth"]

[sub_resource type="Sky" id="Sky_7jm3t"]
sky_material = SubResource("ProceduralSkyMaterial_coxth")

[sub_resource type="Environment" id="Environment_coxth"]
background_mode = 2
background_color = Color(0.08771039, 0.16241324, 0.36877948, 1)
sky = SubResource("Sky_7jm3t")

[sub_resource type="GDScript" id="GDScript_7jm3t"]
script/source = "extends CharacterBody3D
class_name RTSUnit3D

@export var move_speed: float = 5.0
@export var rotation_speed: float = 10.0
@export var arrival_distance: float = 1.0
@export var ground_check_distance: float = 10.0

var flow_field: FlowField3D
var target_position: Vector3 = Vector3.ZERO
var is_moving: bool = false

# Para selección visual
@onready var selection_indicator: MeshInstance3D = $SelectionIndicator
var is_selected: bool = false

func _ready():
	# Obtener referencia al FlowField
	flow_field = get_node_or_null(\"/root/Game/FlowField3D\")
	
	if selection_indicator:
		selection_indicator.visible = false

func set_target(target: Vector3):
	\"\"\"Establece un nuevo objetivo de movimiento\"\"\"
	target_position = target
	is_moving = true

func set_selected(selected: bool):
	\"\"\"Marca la unidad como seleccionada\"\"\"
	is_selected = selected
	if selection_indicator:
		selection_indicator.visible = selected

func _physics_process(delta):
	if not is_moving or not flow_field:
		return
	
	# Verificar si llegamos al objetivo
	var distance_to_target = Vector3(
		global_position.x - target_position.x,
		0,
		global_position.z - target_position.z
	).length()
	
	if distance_to_target < arrival_distance:
		is_moving = false
		velocity = Vector3.ZERO
		return
	
	# Obtener dirección del flow field
	var flow_direction = flow_field.get_flow_direction(global_position)
	
	if flow_direction.length() > 0:
		# Movimiento basado en flow field
		var target_velocity = flow_direction * move_speed
		velocity.x = target_velocity.x
		velocity.z = target_velocity.z
		
		# Rotar hacia la dirección de movimiento
		rotate_towards_direction(flow_direction, delta)
	else:
		# Fallback: moverse directamente al objetivo
		var direction = (target_position - global_position).normalized()
		direction.y = 0  # Mantener en el plano XZ
		
		if direction.length() > 0:
			velocity.x = direction.x * move_speed
			velocity.z = direction.z * move_speed
			rotate_towards_direction(direction, delta)
	
	# Aplicar gravedad
	if not is_on_floor():
		velocity.y -= 9.8 * delta
	
	move_and_slide()
	
	# Ajustar altura al terreno
	adjust_to_ground()

func rotate_towards_direction(direction: Vector3, delta: float):
	\"\"\"Rota suavemente hacia la dirección de movimiento\"\"\"
	if direction.length() < 0.01:
		return
	
	var target_rotation = atan2(direction.x, direction.z)
	var current_rotation = rotation.y
	
	# Interpolación suave
	var new_rotation = lerp_angle(current_rotation, target_rotation, rotation_speed * delta)
	rotation.y = new_rotation

func adjust_to_ground():
	\"\"\"Ajusta la posición Y al terreno usando raycast\"\"\"
	var space_state = get_world_3d().direct_space_state
	var query = PhysicsRayQueryParameters3D.create(
		global_position + Vector3.UP * 2,
		global_position + Vector3.DOWN * ground_check_distance
	)
	
	var result = space_state.intersect_ray(query)
	
	if result:
		# Ajustar altura suavemente
		var target_y = result.position.y
		global_position.y = lerp(global_position.y, target_y, 0.1)

func stop():
	\"\"\"Detiene el movimiento de la unidad\"\"\"
	is_moving = false
	velocity = Vector3.ZERO

func get_unit_info() -> Dictionary:
	\"\"\"Retorna información de la unidad para el UI\"\"\"
	return {
		\"position\": global_position,
		\"is_moving\": is_moving,
		\"target\": target_position,
		\"selected\": is_selected
	}
"

[sub_resource type="CapsuleShape3D" id="CapsuleShape3D_dsjwe"]

[sub_resource type="CapsuleMesh" id="CapsuleMesh_wvw1b"]

[sub_resource type="TorusMesh" id="TorusMesh_7jm3t"]

[node name="RTS" type="Node3D"]
script = SubResource("GDScript_coxth")

[node name="RTScamera" parent="." instance=ExtResource("1_coxth")]

[node name="Plane" parent="." instance=ExtResource("2_7jm3t")]

[node name="DirectionalLight3D" type="DirectionalLight3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 0.8660254, 0.5, 0, -0.5, 0.8660254, 0, 3, 0)

[node name="WorldEnvironment" type="WorldEnvironment" parent="."]
environment = SubResource("Environment_coxth")

[node name="CharacterBody3D" type="CharacterBody3D" parent="."]
script = SubResource("GDScript_7jm3t")

[node name="CollisionShape3D" type="CollisionShape3D" parent="CharacterBody3D"]
shape = SubResource("CapsuleShape3D_dsjwe")

[node name="MeshInstance3D" type="MeshInstance3D" parent="CharacterBody3D"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1.1066487, 0)
mesh = SubResource("CapsuleMesh_wvw1b")

[node name="MeshInstance3D2" type="MeshInstance3D" parent="CharacterBody3D"]
mesh = SubResource("TorusMesh_7jm3t")

[node name="FlowField3D" type="Node3D" parent="."]
script = ExtResource("3_7jm3t")

[node name="SelectionUILayer" type="CanvasLayer" parent="."]
script = ExtResource("4_dsjwe")
